{
  "name": "underscore.deep",
  "version": "0.5.1",
  "description": "Underscore mixins for deeply nested objects",
  "main": "underscore.deep.js",
  "engines": {
    "node": ">=0.10.x"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Clever/underscore.deep.git"
  },
  "scripts": {
    "prepublish": "make",
    "test": "make test"
  },
  "license": "BSD",
  "peerDependencies": {
    "underscore": "1.x"
  },
  "devDependencies": {
    "underscore": "~1.5.2",
    "coffee-script": "~1.6.3",
    "mocha": "~1.13.0"
  },
  "publishConfig": {
    "registry": "https://registry.npmjs.org"
  },
  "readme": "# underscore.deep\n\nUnderscore.deep is a collection of Underscore mixins that operate on nested\nobjects.\n\nThis README is written in [Literate CoffeeScript](http://coffeescript.org/#literate) as a [Mocha](http://visionmedia.github.io/mocha/) test suite, so you can execute all of the examples - just run:\n\n```\nmake README.coffee.md\n```\n\n## Installation\n\n```\nnpm install underscore\nnpm install underscore.deep\n```\n\n## Usage\n\n```\n_ = require 'underscore'\n_.mixin require 'underscore.deep'\n```\n\n## Functions\n\n    describe 'underscore.deep', ->\n      assert = require 'assert'\n      _ = require 'underscore'\n      _.mixin require './underscore.deep'\n\n### _.deepToFlat(obj)\n\nTakes an object and produces a new object with no nested objects, converting any nested objects to sets of fields with dot-notation keys, recursively.\n\n      describe '_.deepToFlat', ->\n\n        it 'does nothing with shallow objects', ->\n          assert.deepEqual _.deepToFlat({}),             {}\n          assert.deepEqual _.deepToFlat( shallow: 1 ),   shallow: 1\n\n        it 'deepToFlats nested objects', ->\n          assert.deepEqual _.deepToFlat( deeply: { nested: 2 } ), 'deeply.nested': 2\n          assert.deepEqual _.deepToFlat(\n            user1:\n              name:\n                first: 'Deep'\n                last: 'Blue'\n              age: 33\n          ),\n            'user1.name.first': 'Deep'\n            'user1.name.last': 'Blue'\n            'user1.age': '33'\n\n### _.deepFromFlat(obj)\n\nTakes an object and produces a new object with no dot-notation keys, converting any set of dot-notation keys with the same prefix to a nested object, recursively.\n\n**Warning:** Any keys with a dot (`.`) in the input object will be converted to nested objects, so if you use dots in your keys you may want to replace them before you call `_.deepFromFlat`.\n\n      describe '_.deepFromFlat', ->\n        it 'does nothing with objects with no dot-notation', ->\n          assert.deepEqual _.deepFromFlat({}),             {}\n          assert.deepEqual _.deepFromFlat( shallow: 1 ),   shallow: 1\n\n        it 'deepFromFlats a flat object', ->\n          assert.deepEqual _.deepFromFlat( 'deeply.nested': 2 ), deeply: { nested: 2 }\n          assert.deepEqual _.deepFromFlat(\n            'user1.name.first': 'Deep'\n            'user1.name.last': 'Blue'\n            'user1.age': '33'\n          ),\n            user1:\n              name:\n                first: 'Deep'\n                last: 'Blue'\n              age: 33\n\n### _.deepToFlat and _.deepFromFlat\n\nTaken as a pair, `_.deepToFlat` and `_.deepFromFlat` have an interesting relationship:\n\n      describe '_.deepToFlat and _.deepFromFlat', ->\n        it 'they undo each other', ->\n          deepObj = a: 1, b: { c: 2 }\n          flatObj = a: 1, 'b.c': 2\n          assert.deepEqual flatObj, _.deepToFlat deepObj\n          assert.deepEqual deepObj, _.deepFromFlat flatObj\n\nThey are inverses (of a sort)! We can reformulate this as a property that holds for any `flatObj` and `deepObj`:\n\n          assert.deepEqual flatObj, _.deepToFlat _.deepFromFlat flatObj\n          assert.deepEqual deepObj, _.deepFromFlat _.deepToFlat deepObj\n\n### _.deepClone(obj)\n\nTakes an object and makes a copy of it, recursively copying any nested objects\nor arrays. Instances of classes, like `Number` or `String`, are *not* cloned.\n\n      describe '_.deepClone', ->\n\n        orig =\n          deepThings:\n            proverbs:\n              quote: 'Computer science is no more about computers' +\n                'than astronomy is about telescopes.'\n              sayer: 'Dijkstra'\n            pools: [\n              { depth: 10 }\n              { depth: 20 }\n              { depth: 30 }\n            ]\n\n        it 'clones an object deeply', ->\n          copy = _.deepClone orig\n          assert.deepEqual copy, orig\n          assert.notStrictEqual copy, orig\n          assert.notStrictEqual copy.deepThings.proverbs, orig.deepThings.proverbs\n          assert.notStrictEqual copy.deepThings.pools, orig.deepThings.pools\n\n        it 'is equivalent to the composition of _.deepFromFlat, _.clone, and _.deepToFlat', ->\n          copy2 = _.deepFromFlat _.clone _.deepToFlat orig\n          assert.deepEqual copy2, orig\n          assert.notEqual copy2, orig\n\n### _.deepHas(obj, key)\n\nTakes an object `obj` and a string `key` (which should be a dot-notation key) and returns true if `obj` has a nested field named `key`.\n\n      describe '_.deepHas', ->\n\n        obj = we: have: to: go: 'deeper'\n\n        it 'returns true if a regular key exists', ->\n          assert.equal _.deepHas(obj, 'we'), true\n\n        it 'returns true if the deep key exists', ->\n          assert.equal _.deepHas(obj, 'we.have'), true\n          assert.equal _.deepHas(obj, 'we.have.to'), true\n          assert.equal _.deepHas(obj, 'we.have.to.go'), true\n\n        it 'returns false if the deep key does not exist', ->\n          assert.equal _.deepHas(obj, 'we.have.to.goop'), false\n\n        it 'is not equivalent to the composition of _.has and _.deepToFlat', ->\n          assert.equal _.deepHas(obj, 'we.have.to.go'), _.has(_.deepToFlat(obj), 'we.have.to.go')\n          assert.equal _.deepHas(obj, 'we.have.to.goop'), _.has(_.deepToFlat(obj), 'we.have.to.goop')\n          assert.notEqual _.deepHas(obj, 'we'), _.has(_.deepToFlat(obj), 'we')\n\n### _.deepKeys(obj)\n\nTakes an object and returns all of its nested keys in dot-notation.\n\nIf you think of a deeply-nested object as a tree, then it will return the paths to all of the tree's leaves. That means it won't return intermediate keys. As a consequence, `_.deepHas(obj, key)` is not equivalent to `_.contains _.deepKeys(obj), key`.\n\n      describe '_.deepKeys', ->\n\n        obj =\n          node1:\n            leaf1: 1\n          node2:\n            node3:\n              leaf2: 2\n              leaf3: 3\n\n        it 'returns dot-notation keys for only the leaf fields of an object', ->\n          assert.deepEqual _.deepKeys(obj), [\n            'node1.leaf1'\n            'node2.node3.leaf2'\n            'node2.node3.leaf3'\n          ]\n\n        it 'is equivalent to the composition of _.keys and _.deepToFlat', ->\n          assert.deepEqual _.deepKeys(obj), _.keys(_.deepToFlat obj)\n\n        it 'does not make _.deepHas equivalent to the composition of _.contains and _.deepKeys', ->\n          assert.notDeepEqual _.contains(_.deepKeys(obj), 'node1'), _.has(obj, 'node1')\n\n### _.deepOmit(obj, keys)\n\nTakes an object and a list of dot-notation keys and returns a new object without those keys.\n\n      foods =\n        fruit:\n          apple: true\n          orange: true\n          carrot: true\n        vegetables:\n          banana: true\n\n      describe '_.deepOmit', ->\n\n        it 'returns an object without the given keys', ->\n          assert.deepEqual _.deepOmit(foods, ['fruit.carrot', 'vegetables']),\n            fruit:\n              apple: true\n              orange: true\n\n### _.deepPick(obj, keys)\n\nTakes an object and a list of dot-notation keys and returns a new object with only those keys. If you pick a key that has a subobject below it, the entire subobject will be included, regardless of whether its subkeys are also picked.\n\n      describe '_.deepPick', ->\n\n        it 'returns an object with only the given keys', ->\n          assert.deepEqual _.deepPick(foods, ['fruit.carrot', 'vegetables']),\n            fruit:\n              carrot: true\n            vegetables:\n              banana: true\n\n### _.deepExtend(destination, source, mutate = false)\n\nTakes an object `destination` and an object `source` and creates a new object with all the deep fields of `destination` and all the deep fields of `source`. Any deep fields with the same deep key in `destination` and `source` will have the value from `source` (so `source` fields overwrite `destination` fields).\n\nUnlike `_.extend`, `_.deepExtend` is pure, so the original objects `destination` and `source` will not be modified. If you really want to mutate `destination` by adding the deep fields of `source`, pass `true` as the third parameter `mutate`.\n\n      describe '_.deepExtend', ->\n\n        destination =\n          name: 'heaven'\n          angels:\n            michael: true\n\n        it 'combines all the deep fields of destination and source', ->\n          assert.deepEqual _.deepExtend(destination, { angels: gabriel: false }),\n            name: 'heaven'\n            angels:\n              michael: true\n              gabriel: false\n\n        it 'overwrites fields of destination with fields from source', ->\n          assert.deepEqual _.deepExtend(destination, { angels: michael: false }),\n            name: 'heaven'\n            angels:\n              michael: false\n\n        it 'does not mutate the input objects', ->\n          assert.notStrictEqual destination, _.deepExtend(destination, { name: 'hell' })\n\n        it 'is equivalent to a weird composition of _.deepFromFlat, _.extend, and _.deepToFlat', ->\n          assert.deepEqual _.deepExtend(destination, { angels: gabriel: false }),\n            _.deepFromFlat _.extend _.deepToFlat(destination), _.deepToFlat({ angels: gabriel: false })\n\n### _.deepMapValues(obj, func)\n\nLike [_.mapValues](#_mapvaluesobj-func), but for deep objects. Constructs a new object by applying function `func` to the value for every deep field in object `obj`.\n\n      describe '_.deepMapValues', ->\n        obj =\n          values:\n            empathy: true\n            responsibility: false\n\n        it 'creates an object by applying func to each deep value in obj', ->\n          assert.deepEqual _.deepMapValues(obj, (v) -> not v),\n            values:\n              empathy: false\n              responsibility: true\n\n        it 'is equivalent to the composition of _.deepFromFlat, _.mapValues, and _.deepToFlat', ->\n          assert.deepEqual _.deepMapValues(obj, (v) -> String v),\n            _.deepFromFlat _.mapValues _.deepToFlat(obj), (v) -> String v\n\n## Non-deep Helpers\n\nSomeday these will probably be moved into their own library, but for now they live here.\n\n### _.isPlainObject(val)\n\nTakes a value `val` and returns `true` if it's a vanilla JS object (i.e. not an instance of any built-in or custom class). Otherwise returns false.\n\n      describe '_.isPlainObject', ->\n\n        it 'returns true for vanilla objects', ->\n          assert.equal _.isPlainObject({}), true\n          assert.equal _.isPlainObject({ vanilla: 'is so plain' }), true\n\n        it 'returns false for other values', ->\n          assert.equal _.isPlainObject(1), false\n          assert.equal _.isPlainObject('chocolate'), false\n          assert.equal _.isPlainObject(new Date()), false\n\n### _.mapValues(obj, func)\n\nTakes an object `obj` and a function `func` and constructs a new object by applying `func` to every value in `obj`. `func` receives two arguments, the value and the key for that value.\n\nSome have [described](https://github.com/jashkenas/underscore/issues/220#issuecomment-12112759) this function as \"the fundamental map over dictionaries.\" Others have [said](https://github.com/jashkenas/underscore/issues/220#issuecomment-1470150) its not \"mainstream enough to deserve to make it into Underscore proper.\" We take no stance in the debate, but we have to admit we use it on the daily.\n\n      describe '_.mapValues', ->\n        obj =\n          respect: 1\n          fairness: 2\n\n        it 'creates an object by applying func to each value in obj', ->\n          assert.deepEqual _.mapValues(obj, (v) -> v * 10),\n            respect: 10\n            fairness: 20\n\n### _.mapKeys(obj, func)\nExactly like [_.mapValues](#_mapvaluesobj-func) but for keys.\n\nNote that the function takes a function takes a key and optionally a value, not the usual mapping function pattern of taking a value and optionally a key\n\n      describe '_.mapKeys', ->\n        obj =\n          animate: 1\n          charge: 2\n\n        it 'creates an object by applying func to each key in obj', ->\n          assert.deepEqual _.mapKeys(obj, (key) -> 're' + key),\n            reanimate: 1\n            recharge: 2\n\n        it 'creates an object by applying func to each key, val in obj', ->\n          assert.deepEqual _.mapKeys(obj, (key, val) -> 're' + key + val),\n            reanimate1: 1\n            recharge2: 2\n",
  "readmeFilename": "README.coffee.md",
  "bugs": {
    "url": "https://github.com/Clever/underscore.deep/issues"
  },
  "homepage": "https://github.com/Clever/underscore.deep#readme",
  "_id": "underscore.deep@0.5.1",
  "_shasum": "072671f48d68735c34223fcfef63e69e5276cc2b",
  "_resolved": "https://registry.npmjs.org/underscore.deep/-/underscore.deep-0.5.1.tgz",
  "_from": "https://registry.npmjs.org/underscore.deep/-/underscore.deep-0.5.1.tgz"
}
